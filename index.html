Absolutely. If the **logic is fine**, the right move is to **upgrade only the visuals** (cabinet look, neon lanes, better ball sprite feel, richer glow, nicer launcher, better effects) without touching the fairness/commit logic.

Below is a **full drop-in replacement** of the **Cyber Pinball Quiz** code you already have, with a significantly improved look:

* Neon “arcade cabinet” frame + side rails
* Lanes look like real gates (chevrons + glass panels)
* Ball looks like a glowing “data packet” with a **hex pattern** + bloom
* Better trail + impact sparks
* Launcher looks like a real plunger (spring + energy meter)
* Bumpers are more alive (pulsing rings + hit flash)
* Small “muzzle flash” style burst when launched
* Still **controlled + fair** (same logic: chosen lane always reachable)

Replace your whole HTML with this:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Cyber Pinball Quiz — GBL (Upgraded Visuals, Same Logic)</title>
  <style>
    :root{
      --bg:#050b18;
      --ink:#eaf0ff;
      --muted:#b9c6ff;

      --panel:rgba(255,255,255,.08);
      --border:rgba(255,255,255,.14);
      --shadow:0 12px 34px rgba(0,0,0,.35);

      --good:#39d98a;
      --bad:#ff5c7a;

      --a:#7c5cff;
      --b:#33d6ff;
      --c:#ff7ad9;

      --gold:#ffd84d;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1200px 680px at 70% 5%, rgba(51,214,255,.18), transparent 60%),
        radial-gradient(1100px 650px at 20% 10%, rgba(124,92,255,.16), transparent 60%),
        radial-gradient(900px 600px at 50% 95%, rgba(255,216,77,.10), transparent 60%),
        linear-gradient(180deg, #040812, var(--bg));
      overflow:hidden;
    }
    .wrap{height:100dvh; display:flex; flex-direction:column;}
    header{
      padding:12px 14px 10px;
      display:flex; gap:10px; justify-content:space-between; align-items:center; flex-wrap:wrap;
    }
    .brand{display:flex; flex-direction:column; gap:2px; min-width:260px;}
    .brand .t{font-weight:950;}
    .brand .s{font-size:12px; color:var(--muted)}
    .hud{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    .pill{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:8px 10px;
      box-shadow:var(--shadow);
      font-size:12px;
      display:flex; gap:8px; align-items:center;
      backdrop-filter: blur(8px);
      user-select:none;
    }
    .pill b{font-size:13px}
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:var(--ink);
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:850;
      box-shadow:var(--shadow);
      user-select:none;
      transition: transform .05s ease;
    }
    .btn:active{transform:translateY(1px)}

    main{flex:1; padding:0 12px 12px; display:flex; flex-direction:column; gap:10px;}
    .row{display:flex; gap:10px; align-items:stretch;}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.04));
      border:1px solid var(--border);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:12px;
      backdrop-filter: blur(10px);
    }
    .qCard{flex:1.15; min-height:170px; position:relative; overflow:hidden;}
    .qTitle{display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap; margin-bottom:6px;}
    .badge{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(100,181,255,.16);
      border:1px solid rgba(100,181,255,.35);
      white-space:nowrap;
      user-select:none;
    }
    .qText{font-size:16px; line-height:1.28; font-weight:950; margin-top:6px;}
    .choices{margin-top:10px; display:grid; gap:6px;}
    .choice{
      display:flex; gap:10px; align-items:center;
      padding:9px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.10);
      font-size:13px;
      user-select:none;
    }
    .tag{
      width:30px; height:30px; border-radius:10px;
      display:grid; place-items:center;
      font-weight:950; color:#0b1220;
      flex:0 0 auto;
    }
    .tag.A{background:var(--a)}
    .tag.B{background:var(--b)}
    .tag.C{background:var(--c)}
    .muted{color:var(--muted)}

    .readBarWrap{
      margin-top:10px;
      padding:10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.10);
      display:none;
    }
    .readLabel{
      display:flex; justify-content:space-between; align-items:center;
      font-size:12px; color:var(--muted); font-weight:800;
      margin-bottom:8px;
    }
    .bar{
      height:10px;
      border-radius:999px;
      background:rgba(255,255,255,.10);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
    }
    .bar > div{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, rgba(51,214,255,.85), rgba(124,92,255,.85));
    }
    .statusLine{
      margin-top:10px;
      padding:10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.10);
      font-size:12px;
      color:var(--muted);
      display:none;
    }

    .gameCard{flex:1.85; display:flex; flex-direction:column; gap:10px; padding:10px;}
    canvas{
      width:100%;
      height:min(56dvh, 580px);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.10));
      box-shadow:var(--shadow);
      touch-action:none;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      align-items:stretch;
    }
    .ctl{
      border-radius:16px;
      padding:14px 10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      box-shadow:var(--shadow);
      user-select:none;
      display:flex; flex-direction:column; gap:4px;
      align-items:center;
      font-weight:950;
      text-align:center;
      min-height:56px;
    }
    .ctl small{font-weight:700; color:var(--muted); line-height:1.2;}
    .footerRow{
      display:flex; gap:10px; flex-wrap:wrap;
      justify-content:space-between; align-items:center;
      padding:2px 2px 0;
    }
    .tiny{font-size:12px; color:var(--muted)}

    .pop{
      position:absolute;
      left:50%; top:56%;
      transform:translate(-50%,-50%);
      padding:12px 14px;
      border-radius:18px;
      font-weight:950;
      display:none;
      z-index:5;
      border:1px solid rgba(255,255,255,.14);
      box-shadow:var(--shadow);
      backdrop-filter: blur(8px);
      text-align:center;
      min-width:320px;
      user-select:none;
    }
    .pop.good{background:rgba(57,217,138,.20)}
    .pop.bad{background:rgba(255,92,122,.18)}
    .pop .why{display:block; margin-top:6px; font-size:12px; color:var(--muted); font-weight:800}

    .overlay{
      position:fixed; inset:0;
      display:none;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      align-items:center; justify-content:center;
      padding:16px;
      z-index:50;
    }
    .modal{
      width:min(900px, 96vw);
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius:22px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
      padding:14px;
    }
    .modal h2{margin:6px 0 8px}
    .modal p, .modal li{color:var(--muted)}
    .modal .row{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; margin-top:12px;}

    @media (max-width: 900px){
      .row{flex-direction:column}
      canvas{height:min(52dvh, 500px);}
      .qText{font-size:15px}
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="t">Cyber Pinball Quiz — GBL</div>
      <div class="s">Upgraded visuals. Same fair logic: your intended lane is always reachable.</div>
    </div>
    <div class="hud">
      <div class="pill">Score: <b id="score">0</b></div>
      <div class="pill">Accuracy: <b id="acc">0%</b></div>
      <div class="pill">Q: <b id="qnum">0</b>/<span id="qtotal">0</span></div>
      <button class="btn" id="howBtn">How to Play</button>
      <button class="btn" id="restartBtn">Restart</button>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="card qCard" aria-live="polite">
        <div class="qTitle">
          <div class="badge" id="topicBadge">Ready</div>
          <div class="tiny muted">Hold to charge, drag to aim, release to launch.</div>
        </div>

        <div class="qText" id="qText">Press Start to begin.</div>
        <div class="choices" id="choices"></div>

        <div class="readBarWrap" id="readWrap">
          <div class="readLabel">
            <span>Reading time…</span>
            <span id="readSecs">0.0s</span>
          </div>
          <div class="bar"><div id="readBar"></div></div>
        </div>

        <div class="statusLine" id="statusLine"></div>
        <div class="pop" id="popup"></div>
      </section>

      <section class="card gameCard">
        <canvas id="c"></canvas>

        <div class="controls">
          <div class="ctl" id="leftBtn" role="button" tabindex="0">Aim ◀ <small>←</small></div>
          <div class="ctl" id="launchBtn" role="button" tabindex="0">Hold & Release <small>Space</small></div>
          <div class="ctl" id="rightBtn" role="button" tabindex="0">Aim ▶ <small>→</small></div>
        </div>

        <div class="footerRow">
          <div class="tiny">Tip: Tap canvas to aim. Hold in launcher area to charge. Release to launch.</div>
          <button class="btn" id="startBtn">Start</button>
        </div>
      </section>
    </div>
  </main>
</div>

<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="modalTitle">How to Play</h2>
    <div id="modalBody">
      <ul>
        <li>A question appears and the game pauses for a few seconds so you can read.</li>
        <li>Then aim and launch the glowing “data packet” ball toward lane <b>A</b>, <b>B</b>, or <b>C</b>.</li>
        <li><b>Mobile / Mouse:</b> press & hold to charge, drag slightly to aim, release to launch.</li>
        <li><b>Keyboard:</b> ← / → to aim, hold Space to charge, release Space to launch.</li>
        <li>Correct lane: <b>+10</b>. Wrong lane: <b>0</b>. One launch per question.</li>
      </ul>
      <p class="muted">This is a controlled pinball: it never “cheats” your intended lane.</p>
    </div>
    <div class="row">
      <button class="btn" id="closeModal">Close</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   PID optional: ?pid=UOU123
   ========================================================= */
const params = new URLSearchParams(location.search);
const PID = params.get("pid") || "UOU-ANON";

/* =========================================================
   Question bank (keep / replace with your chapter MCQs)
   ========================================================= */
const QUESTION_BANK = [
  { id:"Q1", topic:"Smartphone Security",
    q:"Which practice best reduces risk from malicious apps?",
    options:["Install only from official stores","Disable screen lock","Keep Bluetooth always ON"],
    correctText:"Install only from official stores",
    why:"Official stores reduce exposure to unknown, repackaged or malicious apps."
  },
  { id:"Q2", topic:"Android Security",
    q:"Device encryption on Android primarily protects data:",
    options:["When the device is lost or powered off","Only when Wi-Fi is on","Only inside a browser"],
    correctText:"When the device is lost or powered off",
    why:"Encryption protects stored data, especially if the device is stolen or offline."
  },
  { id:"Q3", topic:"iOS Security",
    q:"On iPhone, enabling a strong passcode improves:",
    options:["Data protection for stored content","Camera quality","Battery capacity"],
    correctText:"Data protection for stored content",
    why:"A strong passcode strengthens iOS data protection mechanisms."
  },
  { id:"Q4", topic:"Smartphone Security",
    q:"Using public Wi-Fi is risky mainly due to:",
    options:["Possible interception and rogue access points","Lower screen brightness","Extra storage usage"],
    correctText:"Possible interception and rogue access points",
    why:"Public networks can be monitored or spoofed to capture traffic and credentials."
  },
  { id:"Q5", topic:"Android Security",
    q:"Granting unnecessary app permissions can lead to:",
    options:["Data leakage and privacy loss","Faster charging","Better speaker sound"],
    correctText:"Data leakage and privacy loss",
    why:"Excess permissions may expose contacts, location, files, or messages."
  },
  { id:"Q6", topic:"iOS Security",
    q:"A key benefit of “Find My iPhone” is:",
    options:["Locate and remotely erase a lost phone","Increase download speed","Automatically jailbreak the phone"],
    correctText:"Locate and remotely erase a lost phone",
    why:"Find My supports location tracking and remote wipe to protect data."
  },
  { id:"Q7", topic:"Smartphone Security",
    q:"Best immediate action when you suspect a phishing link was clicked?",
    options:["Change passwords and enable 2FA","Turn up volume","Ignore and keep using normally"],
    correctText:"Change passwords and enable 2FA",
    why:"Resetting credentials + 2FA reduces account takeover risk."
  },
  { id:"Q8", topic:"Android Security",
    q:"Rooting a phone generally:",
    options:["Increases attack surface by bypassing protections","Always improves security","Only changes wallpaper features"],
    correctText:"Increases attack surface by bypassing protections",
    why:"Rooting weakens system security controls and sandboxing."
  },
  { id:"Q9", topic:"iOS Security",
    q:"Jailbreaking an iPhone typically:",
    options:["Reduces built-in security restrictions","Is required for encryption","Prevents all malware"],
    correctText:"Reduces built-in security restrictions",
    why:"Jailbreak removes Apple restrictions and can weaken the security model."
  },
];

/* =========================================================
   Helpers
   ========================================================= */
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

/* =========================================================
   UI refs
   ========================================================= */
const scoreEl = document.getElementById("score");
const accEl   = document.getElementById("acc");
const qnumEl  = document.getElementById("qnum");
const qtotalEl= document.getElementById("qtotal");
const topicBadge = document.getElementById("topicBadge");
const qTextEl = document.getElementById("qText");
const choicesEl = document.getElementById("choices");
const popupEl = document.getElementById("popup");
const readWrap = document.getElementById("readWrap");
const readBar  = document.getElementById("readBar");
const readSecs = document.getElementById("readSecs");
const statusLine = document.getElementById("statusLine");

const overlay = document.getElementById("overlay");
document.getElementById("howBtn").onclick = ()=> overlay.style.display="flex";
document.getElementById("closeModal").onclick = ()=> overlay.style.display="none";

/* =========================================================
   Game tuning (logic unchanged)
   ========================================================= */
const READ_PAUSE_MS = 4500;
const AIM_TIME_LIMIT_MS = 16000;
const FEEDBACK_MS = 950;
const QUESTIONS_PER_RUN = 9;

const DT = 1/60;
const BALL_R = 10;
const MAX_POWER = 18;
const STEER_STRENGTH = 0.085;
const DRAG = 0.992;
const BOUNCE = 0.82;
const BUMPER_BOUNCE = 1.05;

/* =========================================================
   Canvas + board geometry
   ========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function cssVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

let stars=[];
let dust=[];
function initBackdrop(){
  const r = canvas.getBoundingClientRect();
  stars=[];
  dust=[];
  for(let i=0;i<70;i++){
    stars.push({x:Math.random()*r.width, y:Math.random()*r.height*0.85, r:0.8+Math.random()*1.8, t:Math.random()*6.28});
  }
  for(let i=0;i<85;i++){
    dust.push({x:Math.random()*r.width, y:Math.random()*r.height, a:0.10+Math.random()*0.18, s:0.25+Math.random()*0.65});
  }
}

/* Board parts */
const board = {
  W:0,H:0,
  pad:0,
  laneY:0, laneH:0,
  lanes:[],
  launcher:{x:0,y:0,w:0,h:0},
  bumpers:[],
  walls:{left:0,right:0,top:0,bottom:0},
  rail:{}
};

function buildBoard(){
  const r = canvas.getBoundingClientRect();
  board.W = r.width;
  board.H = r.height;
  board.pad = Math.round(Math.min(board.W, board.H) * 0.062);

  board.walls = {
    left: board.pad,
    right: board.W - board.pad,
    top: board.pad,
    bottom: board.H - board.pad
  };

  board.laneH = Math.round(board.H * 0.14);
  board.laneY = board.walls.top + Math.round(board.H * 0.02);
  const laneAreaW = board.walls.right - board.walls.left;
  const laneW = laneAreaW / 3;

  board.lanes = [
    {key:"A", x:board.walls.left + laneW*0, w:laneW},
    {key:"B", x:board.walls.left + laneW*1, w:laneW},
    {key:"C", x:board.walls.left + laneW*2, w:laneW},
  ];

  const lw = Math.round(laneAreaW * 0.28);
  const lh = Math.round(board.H * 0.18);
  board.launcher = {
    x: board.W/2 - lw/2,
    y: board.walls.bottom - lh - Math.round(board.H*0.02),
    w: lw,
    h: lh
  };

  const midY = board.laneY + board.laneH + (board.H*0.20);
  board.bumpers = [
    {x: board.W*0.30, y: midY, r: 18, flash:0},
    {x: board.W*0.50, y: midY + 56, r: 20, flash:0},
    {x: board.W*0.70, y: midY, r: 18, flash:0},
  ];

  // side rails for cabinet look
  const railW = Math.max(16, Math.round(board.W*0.04));
  board.rail = {w:railW};
}

function roundRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* =========================================================
   State
   ========================================================= */
const state = {
  running:false,
  phase:"menu", // menu | read | aim | flight | feedback | end
  score:0, correct:0, attempted:0,
  questions:[], qIndex:0, current:null,

  readStart:0, readUntil:0,
  aimStart:0, aimUntil:0,
  decisionStart:0,

  aimX:0,
  power:0,
  charging:false,
  chosenLane:null,

  ball:{x:0,y:0,vx:0,vy:0,active:false,trail:[]},

  particles:[],
  floatPop:[],
  log:[],

  // subtle shake
  shake:0,
  shakeX:0,
  shakeY:0,
};

function updateHUD(){
  scoreEl.textContent = String(state.score);
  const acc = state.attempted ? Math.round((state.correct/state.attempted)*100) : 0;
  accEl.textContent = acc + "%";
  qnumEl.textContent = String(state.attempted);
  qtotalEl.textContent = String(state.questions.length);
}
function setStatus(text, show=true){
  statusLine.textContent = text;
  statusLine.style.display = show ? "block" : "none";
}
function showPopup(ok, correctKey, why){
  popupEl.className = "pop " + (ok ? "good" : "bad");
  popupEl.style.display = "block";
  popupEl.innerHTML = (ok ? "✅ Correct! (+10)" : "❌ Wrong!") +
    `<span class="why">Correct: ${correctKey}. ${escapeHtml(why)}</span>`;
  setTimeout(()=> popupEl.style.display="none", FEEDBACK_MS);
}

/* =========================================================
   Question prep: shuffle options + balance correct letters
   ========================================================= */
function prepareQuestionsBalanced(){
  const selected = shuffle(QUESTION_BANK).slice(0, Math.min(QUESTIONS_PER_RUN, QUESTION_BANK.length));
  const n = selected.length;

  const base = Math.floor(n/3);
  const targets = {A:base, B:base, C:base};
  let rem = n - 3*base;
  const order = shuffle(["A","B","C"]);
  for(let i=0;i<rem;i++) targets[order[i]]++;

  const used = {A:0,B:0,C:0};

  return selected.map(q0=>{
    const opts = q0.options.slice();
    let picked = null;

    for(let tries=0; tries<80; tries++){
      const sh = shuffle(opts);
      const map = {A:sh[0], B:sh[1], C:sh[2]};
      const correct = (map.A===q0.correctText) ? "A" : (map.B===q0.correctText) ? "B" : "C";

      if(used[correct] < targets[correct]){
        picked = {map, correct};
        break;
      }
      if(!picked) picked = {map, correct};
    }
    used[picked.correct]++;

    return {
      id:q0.id, topic:q0.topic, q:q0.q,
      A:picked.map.A, B:picked.map.B, C:picked.map.C,
      correct:picked.correct,
      correctText:q0.correctText,
      why:q0.why
    };
  });
}

function renderQuestion(q){
  state.current = q;
  topicBadge.textContent = q.topic;
  qTextEl.textContent = q.q;
  choicesEl.innerHTML = `
    <div class="choice"><div class="tag A">A</div><div><b>${escapeHtml(q.A)}</b></div></div>
    <div class="choice"><div class="tag B">B</div><div><b>${escapeHtml(q.B)}</b></div></div>
    <div class="choice"><div class="tag C">C</div><div><b>${escapeHtml(q.C)}</b></div></div>
  `;
}

/* =========================================================
   Ball / Launch logic (unchanged)
   ========================================================= */
function resetBall(){
  const L = board.launcher;
  state.ball.x = L.x + L.w/2;
  state.ball.y = L.y + L.h - 18;
  state.ball.vx = 0;
  state.ball.vy = 0;
  state.ball.active = false;
  state.ball.trail = [];
  state.chosenLane = null;
  state.aimX = 0;
  state.power = 0;
  state.charging = false;
}
function laneFromAim(aimX){
  if(aimX < -0.22) return "A";
  if(aimX >  0.22) return "C";
  return "B";
}
function laneCenterX(key){
  const lane = board.lanes.find(l=>l.key===key);
  return lane.x + lane.w/2;
}
function launchBall(){
  if(state.phase !== "aim") return;

  state.chosenLane = laneFromAim(state.aimX);

  const speed = 8 + (MAX_POWER-8) * state.power;
  const dx = clamp(state.aimX, -1, 1);

  state.ball.vx = dx * (speed * 0.55);
  state.ball.vy = -speed;

  state.ball.active = true;
  state.phase = "flight";
  setStatus(`Launched toward lane ${state.chosenLane}.`, true);

  // launch spark
  burst(state.ball.x, state.ball.y, "rgba(255,216,77,.95)", 22);
}

/* =========================================================
   Input
   ========================================================= */
const input = {left:false, right:false, spaceDown:false};

window.addEventListener("keydown",(e)=>{
  const k=e.code;
  if(["ArrowLeft","ArrowRight","Space"].includes(k)) e.preventDefault();
  if(k==="ArrowLeft") input.left=true;
  if(k==="ArrowRight") input.right=true;

  if(k==="Space"){
    if(state.phase==="aim" && !input.spaceDown){
      input.spaceDown = true;
      startCharging();
    }
  }
});
window.addEventListener("keyup",(e)=>{
  const k=e.code;
  if(k==="ArrowLeft") input.left=false;
  if(k==="ArrowRight") input.right=false;

  if(k==="Space"){
    if(state.phase==="aim" && input.spaceDown){
      input.spaceDown = false;
      stopChargingAndLaunch();
    }
  }
});

function bindHold(btn, onDown, onUp){
  btn.addEventListener("pointerdown",(e)=>{ e.preventDefault(); onDown(); });
  btn.addEventListener("pointerup",(e)=>{ e.preventDefault(); onUp(); });
  btn.addEventListener("pointercancel",(e)=>{ e.preventDefault(); onUp(); });
}
bindHold(document.getElementById("leftBtn"), ()=>input.left=true, ()=>input.left=false);
bindHold(document.getElementById("rightBtn"),()=>input.right=true,()=>input.right=false);
bindHold(document.getElementById("launchBtn"), ()=>startCharging(), ()=>stopChargingAndLaunch());

function pointerPos(ev){
  const rect = canvas.getBoundingClientRect();
  return {x: (ev.clientX - rect.left), y:(ev.clientY - rect.top)};
}
canvas.addEventListener("pointerdown",(e)=>{
  canvas.setPointerCapture(e.pointerId);
  if(state.phase !== "aim") return;

  const p = pointerPos(e);
  const L = board.launcher;
  const inLauncher = (p.x >= L.x-30 && p.x <= L.x+L.w+30 && p.y >= L.y-20 && p.y <= L.y+L.h+30);

  updateAimFromX(p.x);
  if(inLauncher) startCharging();
});
canvas.addEventListener("pointermove",(e)=>{
  if(state.phase !== "aim") return;
  updateAimFromX(pointerPos(e).x);
});
canvas.addEventListener("pointerup",()=>{
  if(state.phase !== "aim") return;
  if(state.charging) stopChargingAndLaunch();
});

function updateAimFromX(x){
  const mid = board.W/2;
  const span = board.W*0.34;
  state.aimX = clamp((x - mid)/span, -1, 1);
}
function startCharging(){
  if(state.phase !== "aim") return;
  state.charging = true;
}
function stopChargingAndLaunch(){
  if(state.phase !== "aim") return;
  if(!state.charging) return;
  state.charging = false;
  launchBall();
}

/* =========================================================
   Logging + scoring
   ========================================================= */
function addFloatPop(x, y, text, color, ms=650){
  state.floatPop.push({x,y,text,color,until:performance.now()+ms});
}
function burst(x,y,color,count=18){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const sp = 1.6 + Math.random()*3.4;
    state.particles.push({
      x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp-1.2,
      born:performance.now(), life:520+Math.random()*320,
      color, r:1.4+Math.random()*2.6
    });
  }
}
function shake(intensity){
  state.shake = Math.max(state.shake, intensity);
}
function scoreForLane(selectedLane){
  const q = state.current;
  const ok = (selectedLane === q.correct);

  state.attempted++;
  if(ok){
    state.correct++;
    state.score += 10;
    addFloatPop(board.W*0.5, board.H*0.52, "+10", "rgba(57,217,138,.95)", 700);
    burst(board.W*0.5, board.H*0.48, "rgba(57,217,138,.95)", 26);
  }else{
    addFloatPop(board.W*0.5, board.H*0.52, "0", "rgba(255,255,255,.85)", 650);
    burst(board.W*0.5, board.H*0.48, "rgba(255,92,122,.95)", 20);
    shake(4.5);
  }

  const rt = Math.max(0, Math.round(performance.now() - state.decisionStart));

  state.log.push({
    ts: new Date().toISOString(),
    pid: PID,
    qid: q.id,
    topic: q.topic,
    option_order: `A:${q.A} | B:${q.B} | C:${q.C}`,
    selected: selectedLane,
    intended: state.chosenLane || "NA",
    correct: q.correct,
    is_correct: ok ? 1 : 0,
    response_ms: rt,
    score_after: state.score
  });

  updateHUD();
  showPopup(ok, q.correct, q.why);

  state.phase = "feedback";
  setTimeout(()=> nextQuestion(), FEEDBACK_MS);
}
function noAnswer(reason){
  if(state.phase === "feedback" || state.phase === "end") return;

  state.attempted++;
  const q = state.current;
  const rt = Math.max(0, Math.round(performance.now() - state.decisionStart));

  state.log.push({
    ts: new Date().toISOString(),
    pid: PID,
    qid: q.id,
    topic: q.topic,
    option_order: `A:${q.A} | B:${q.B} | C:${q.C}`,
    selected: "NA",
    intended: "NA",
    correct: q.correct,
    is_correct: 0,
    response_ms: rt,
    score_after: state.score
  });

  updateHUD();
  showPopup(false, q.correct, reason || "No answer recorded.");
  shake(3.0);
  state.phase = "feedback";
  setTimeout(()=> nextQuestion(), FEEDBACK_MS);
}

/* =========================================================
   Physics (same logic)
   ========================================================= */
function stepAim(){
  if(input.left) state.aimX = clamp(state.aimX - 0.03, -1, 1);
  if(input.right) state.aimX = clamp(state.aimX + 0.03, -1, 1);

  if(state.charging){
    state.power = clamp(state.power + 0.015, 0, 1);
  }else{
    state.power = clamp(state.power - 0.010, 0, 1);
  }

  if(performance.now() >= state.aimUntil){
    noAnswer("Time expired (no launch).");
  }
}

function collideWalls(){
  const b = state.ball;
  const W = board.walls;

  if(b.x - BALL_R < W.left){
    b.x = W.left + BALL_R;
    b.vx = Math.abs(b.vx) * BOUNCE;
    burst(b.x, b.y, "rgba(255,255,255,.55)", 10);
  }
  if(b.x + BALL_R > W.right){
    b.x = W.right - BALL_R;
    b.vx = -Math.abs(b.vx) * BOUNCE;
    burst(b.x, b.y, "rgba(255,255,255,.55)", 10);
  }
  if(b.y - BALL_R < W.top){
    b.y = W.top + BALL_R;
    b.vy = Math.abs(b.vy) * BOUNCE;
    burst(b.x, b.y, "rgba(255,255,255,.55)", 10);
  }
  if(b.y + BALL_R > W.bottom){
    b.y = W.bottom - BALL_R;
    b.vy *= -0.3;
    b.vx *= 0.6;
    noAnswer("Ball did not enter any lane.");
  }
}

function collideBumpers(){
  const b = state.ball;
  for(const bm of board.bumpers){
    const dx = b.x - bm.x;
    const dy = b.y - bm.y;
    const dist = Math.hypot(dx,dy);
    const minD = BALL_R + bm.r;
    if(dist < minD){
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);
      b.x = bm.x + nx * (minD + 0.5);
      b.y = bm.y + ny * (minD + 0.5);

      const dot = b.vx*nx + b.vy*ny;
      b.vx = (b.vx - 2*dot*nx) * BUMPER_BOUNCE;
      b.vy = (b.vy - 2*dot*ny) * BUMPER_BOUNCE;

      bm.flash = Math.max(bm.flash, 1.0);
      burst(bm.x, bm.y, "rgba(51,214,255,.85)", 18);
      shake(2.0);
    }
  }
}

function checkLaneEntry(){
  const b = state.ball;
  const laneY0 = board.laneY;
  const laneY1 = board.laneY + board.laneH;
  if(b.y - BALL_R <= laneY1 && b.y + BALL_R >= laneY0){
    for(const lane of board.lanes){
      if(b.x >= lane.x && b.x <= lane.x + lane.w){
        state.ball.active = false;
        burst(b.x, b.y, "rgba(255,255,255,.85)", 18);
        scoreForLane(lane.key);
        break;
      }
    }
  }
}

function steerTowardChosenLane(){
  const b = state.ball;
  if(!state.chosenLane) return;
  const targetX = laneCenterX(state.chosenLane);
  const dx = targetX - b.x;
  b.vx += dx * STEER_STRENGTH * 0.0028;
  if(b.vy > -2) b.vy -= 0.06;
}

function stepFlight(){
  const b = state.ball;
  if(!b.active) return;

  steerTowardChosenLane();
  b.x += b.vx;
  b.y += b.vy;

  b.vx *= DRAG;
  b.vy *= DRAG;

  collideWalls();
  collideBumpers();

  b.trail.push({x:b.x,y:b.y, t:performance.now()});
  if(b.trail.length > 22) b.trail.shift();

  checkLaneEntry();
}

/* =========================================================
   Rendering upgrades (new visuals)
   ========================================================= */
function drawBackdrop(now){
  const r = canvas.getBoundingClientRect();

  // drifting dust
  for(const d of dust){
    d.y += d.s;
    if(d.y > r.height+20){ d.y = -20; d.x = Math.random()*r.width; }
    ctx.globalAlpha = d.a;
    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.beginPath();
    ctx.arc(d.x, d.y, 1.0, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // twinkle stars
  for(const s of stars){
    const tw = 0.45 + 0.55*Math.sin(now/700 + s.t);
    ctx.globalAlpha = 0.10 + tw*0.55;
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawCabinet(){
  const W = board.W, H = board.H;
  const p = board.pad;

  // cabinet outer neon
  ctx.save();
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "rgba(124,92,255,.55)";
  roundRect(p-10, p-10, W-2*(p-10), H-2*(p-10), 22);
  ctx.fill();

  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "rgba(51,214,255,.45)";
  roundRect(p-14, p-14, W-2*(p-14), H-2*(p-14), 24);
  ctx.fill();
  ctx.restore();

  // inner playfield glass
  const g = ctx.createLinearGradient(0, p, 0, H-p);
  g.addColorStop(0,"rgba(255,255,255,.08)");
  g.addColorStop(1,"rgba(0,0,0,.20)");
  ctx.fillStyle = g;
  roundRect(p, p, W-2*p, H-2*p, 18);
  ctx.fill();

  // side rails
  const railW = board.rail.w;
  const leftX = p - Math.round(railW*0.35);
  const rightX = W - p - Math.round(railW*0.65);

  const rg = ctx.createLinearGradient(0, p, 0, H-p);
  rg.addColorStop(0,"rgba(255,216,77,.22)");
  rg.addColorStop(1,"rgba(255,216,77,.08)");

  ctx.fillStyle = rg;
  roundRect(leftX, p+8, railW, H-2*p-16, 16);
  ctx.fill();
  roundRect(rightX, p+8, railW, H-2*p-16, 16);
  ctx.fill();

  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 2;
  roundRect(leftX+2, p+10, railW-4, H-2*p-20, 14);
  ctx.stroke();
  roundRect(rightX+2, p+10, railW-4, H-2*p-20, 14);
  ctx.stroke();

  // subtle diagonal shine
  ctx.save();
  ctx.globalAlpha = 0.10;
  ctx.fillStyle = "rgba(255,255,255,.9)";
  ctx.beginPath();
  ctx.moveTo(p+30, p+10);
  ctx.lineTo(p+120, p+10);
  ctx.lineTo(W-p-50, H-p-10);
  ctx.lineTo(W-p-140, H-p-10);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawGrid(){
  const p = board.pad;
  const W = board.W, H = board.H;
  ctx.save();
  ctx.globalAlpha = 0.10;
  ctx.strokeStyle = "rgba(255,255,255,.45)";
  ctx.lineWidth = 1;
  for(let x=p+14; x<W-p; x+=30){
    ctx.beginPath(); ctx.moveTo(x,p+14); ctx.lineTo(x,H-p-14); ctx.stroke();
  }
  for(let y=p+14; y<H-p; y+=30){
    ctx.beginPath(); ctx.moveTo(p+14,y); ctx.lineTo(W-p-14,y); ctx.stroke();
  }
  ctx.restore();
}

function drawLaneGate(lane, now){
  const y = board.laneY;
  const h = board.laneH;
  const innerX = lane.x + 10;
  const innerW = lane.w - 20;

  const color = lane.key==="A" ? cssVar("--a") : lane.key==="B" ? cssVar("--b") : cssVar("--c");

  // glass panel
  ctx.save();
  const pulse = 0.35 + 0.30*Math.sin(now/260 + (lane.key.charCodeAt(0)%7));
  ctx.globalAlpha = 0.18 + pulse*0.22;
  ctx.fillStyle = "rgba(255,255,255,.14)";
  roundRect(innerX, y+10, innerW, h-20, 16);
  ctx.fill();

  // neon border
  ctx.globalAlpha = 0.85;
  ctx.strokeStyle = color;
  ctx.lineWidth = 2.5;
  roundRect(innerX, y+10, innerW, h-20, 16);
  ctx.stroke();

  // chevrons
  ctx.globalAlpha = 0.20 + pulse*0.20;
  ctx.fillStyle = color;
  const cx = lane.x + lane.w/2;
  const cy = y + h/2 + 6;
  for(let i=0;i<3;i++){
    const off = (i-1)*18;
    ctx.beginPath();
    ctx.moveTo(cx-26+off, cy-14);
    ctx.lineTo(cx-10+off, cy-28);
    ctx.lineTo(cx+6+off, cy-14);
    ctx.lineTo(cx-10+off, cy);
    ctx.closePath();
    ctx.fill();
  }

  // label
  ctx.globalAlpha = 1;
  ctx.fillStyle = color;
  ctx.font = "950 22px system-ui,Segoe UI,Arial";
  ctx.fillText(lane.key, cx - 7, y + 34);

  ctx.restore();
}

function drawLanes(now){
  for(const lane of board.lanes) drawLaneGate(lane, now);
}

function drawBumpers(now){
  for(const bm of board.bumpers){
    // flash decay
    bm.flash = Math.max(0, bm.flash - 0.045);

    const pulse = 0.35 + 0.25*Math.sin(now/240 + bm.x*0.01);
    const glowA = 0.14 + pulse*0.18;

    // outer glow
    ctx.save();
    ctx.globalAlpha = glowA + bm.flash*0.25;
    ctx.fillStyle = "rgba(51,214,255,.9)";
    ctx.beginPath();
    ctx.arc(bm.x, bm.y, bm.r+14, 0, Math.PI*2);
    ctx.fill();

    // ring
    ctx.globalAlpha = 0.55 + bm.flash*0.35;
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(bm.x, bm.y, bm.r+6 + Math.sin(now/180)*2.0, 0, Math.PI*2);
    ctx.stroke();

    // core
    const g = ctx.createRadialGradient(bm.x-6, bm.y-8, 2, bm.x, bm.y, bm.r);
    g.addColorStop(0,"rgba(255,255,255,.55)");
    g.addColorStop(1,"rgba(51,214,255,.08)");
    ctx.globalAlpha = 1;
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(bm.x, bm.y, bm.r, 0, Math.PI*2);
    ctx.fill();

    // tiny shield icon (simple)
    ctx.globalAlpha = 0.55 + pulse*0.25;
    ctx.fillStyle = "rgba(255,255,255,.25)";
    ctx.beginPath();
    ctx.moveTo(bm.x, bm.y-bm.r*0.55);
    ctx.quadraticCurveTo(bm.x+bm.r*0.55, bm.y-bm.r*0.15, bm.x, bm.y+bm.r*0.62);
    ctx.quadraticCurveTo(bm.x-bm.r*0.55, bm.y-bm.r*0.15, bm.x, bm.y-bm.r*0.55);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }
}

function drawLauncher(){
  const L = board.launcher;
  const midX = L.x + L.w/2;
  const midY = L.y + 26;

  // launcher body
  const g = ctx.createLinearGradient(L.x, L.y, L.x, L.y+L.h);
  g.addColorStop(0,"rgba(255,255,255,.10)");
  g.addColorStop(1,"rgba(0,0,0,.24)");
  ctx.fillStyle = g;
  roundRect(L.x, L.y, L.w, L.h, 18);
  ctx.fill();

  // neon outline
  ctx.strokeStyle = "rgba(255,216,77,.22)";
  ctx.lineWidth = 3;
  roundRect(L.x+2, L.y+2, L.w-4, L.h-4, 16);
  ctx.stroke();

  // spring / plunger
  ctx.save();
  ctx.globalAlpha = 0.70;
  ctx.strokeStyle = "rgba(255,216,77,.45)";
  ctx.lineWidth = 2;
  const springTop = L.y + 42;
  const springBottom = L.y + L.h - 30;
  const coils = 7;
  ctx.beginPath();
  for(let i=0;i<=coils;i++){
    const t = i/coils;
    const y = springTop + t*(springBottom - springTop);
    const x = midX + Math.sin(t*Math.PI*coils) * (10 + state.power*8);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  // aim guide (neon)
  const aimLen = 100 + state.power*70;
  const dx = state.aimX;
  ctx.save();
  ctx.globalAlpha = 0.75;
  ctx.strokeStyle = "rgba(255,216,77,.70)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(midX, midY);
  ctx.lineTo(midX + dx*aimLen*0.60, midY - aimLen);
  ctx.stroke();

  // dotted guide
  ctx.globalAlpha = 0.35;
  ctx.setLineDash([6,8]);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(midX, midY);
  ctx.lineTo(midX + dx*aimLen*0.80, midY - aimLen*1.10);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // power bar
  const barW = L.w*0.80;
  const barX = L.x + (L.w-barW)/2;
  const barY = L.y + L.h - 18;

  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "rgba(255,255,255,.12)";
  roundRect(barX, barY, barW, 10, 999);
  ctx.fill();

  ctx.globalAlpha = 0.95;
  const pg = ctx.createLinearGradient(barX, barY, barX+barW, barY);
  pg.addColorStop(0,"rgba(51,214,255,.85)");
  pg.addColorStop(0.55,"rgba(255,216,77,.85)");
  pg.addColorStop(1,"rgba(255,92,122,.80)");
  ctx.fillStyle = pg;
  roundRect(barX, barY, barW*state.power, 10, 999);
  ctx.fill();
  ctx.globalAlpha = 1;
}

function drawHexBall(now){
  const b = state.ball;

  // trail (stronger)
  for(let i=0;i<b.trail.length;i++){
    const p = b.trail[i];
    const age = (now - p.t);
    const a = clamp(1 - age/420, 0, 1);
    ctx.globalAlpha = a*0.28;
    ctx.fillStyle = "rgba(51,214,255,.95)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, BALL_R*(0.65 + i/b.trail.length*0.55), 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // outer bloom
  ctx.save();
  ctx.globalCompositeOperation = "lighter";
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "rgba(51,214,255,.95)";
  ctx.beginPath();
  ctx.arc(b.x, b.y, BALL_R+18, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // core glow
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "rgba(51,214,255,.85)";
  ctx.beginPath();
  ctx.arc(b.x, b.y, BALL_R+9, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // core sphere
  const g = ctx.createRadialGradient(b.x-5, b.y-6, 2, b.x, b.y, BALL_R);
  g.addColorStop(0,"rgba(255,255,255,.96)");
  g.addColorStop(1,"rgba(51,214,255,.35)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(b.x, b.y, BALL_R, 0, Math.PI*2);
  ctx.fill();

  // hex pattern (very light)
  ctx.save();
  ctx.beginPath();
  ctx.arc(b.x, b.y, BALL_R-1, 0, Math.PI*2);
  ctx.clip();
  ctx.globalAlpha = 0.16;
  ctx.strokeStyle = "rgba(255,255,255,.9)";
  ctx.lineWidth = 1;
  const hexR = 4.2;
  for(let yy=b.y-BALL_R; yy<=b.y+BALL_R; yy+=hexR*1.6){
    for(let xx=b.x-BALL_R; xx<=b.x+BALL_R; xx+=hexR*1.8){
      const off = ((Math.round((yy-(b.y-BALL_R))/(hexR*1.6)) % 2) ? hexR*0.9 : 0);
      const cx = xx + off;
      const cy = yy;
      ctx.beginPath();
      for(let k=0;k<6;k++){
        const ang = Math.PI/3*k + Math.PI/6;
        const px = cx + Math.cos(ang)*hexR;
        const py = cy + Math.sin(ang)*hexR;
        if(k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.stroke();
    }
  }
  ctx.restore();

  // ring
  ctx.strokeStyle = "rgba(255,255,255,.22)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(b.x, b.y, BALL_R-2, 0, Math.PI*2);
  ctx.stroke();

  // small direction spark
  ctx.save();
  ctx.globalAlpha = 0.55;
  ctx.strokeStyle = "rgba(255,216,77,.55)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(b.x+3, b.y-2, BALL_R-5, -0.5, 0.6);
  ctx.stroke();
  ctx.restore();
}

function drawFX(now){
  // particles
  state.particles = state.particles.filter(pt => (now - pt.born) < pt.life);
  for(const pt of state.particles){
    const t = (now - pt.born) / pt.life;
    pt.x += pt.vx;
    pt.y += pt.vy;
    pt.vy += 0.06;

    ctx.globalAlpha = (1-t);
    ctx.fillStyle = pt.color;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // float pops
  state.floatPop = state.floatPop.filter(p => now < p.until);
  for(const p of state.floatPop){
    const t = 1 - ((p.until - now)/650);
    ctx.globalAlpha = 1 - t;
    ctx.fillStyle = p.color;
    ctx.font = "950 18px system-ui,Segoe UI,Arial";
    ctx.fillText(p.text, p.x - 14, p.y - t*22);
  }
  ctx.globalAlpha = 1;
}

function drawPhaseHint(){
  const W = board.W, H = board.H;
  ctx.save();
  ctx.globalAlpha = 0.70;
  ctx.fillStyle = "rgba(0,0,0,.18)";
  ctx.fillRect(0, H-38, W, 38);

  ctx.globalAlpha = 1;
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = "900 12px system-ui,Segoe UI,Arial";

  if(state.phase==="read"){
    ctx.fillText("Reading time… (launch disabled)", 12, H-16);
  }else if(state.phase==="aim"){
    const lane = laneFromAim(state.aimX);
    ctx.fillText(`Aim: ${lane}  |  Hold to charge, release to launch`, 12, H-16);
  }else if(state.phase==="flight"){
    ctx.fillText("Ball in motion…", 12, H-16);
  }else{
    ctx.fillText("Cyber Pinball Quiz", 12, H-16);
  }
  ctx.restore();
}

function draw(now){
  const r = canvas.getBoundingClientRect();
  ctx.clearRect(0,0,r.width,r.height);

  // shake
  if(state.shake > 0){
    state.shake *= 0.85;
    const a = Math.random()*Math.PI*2;
    state.shakeX = Math.cos(a)*state.shake;
    state.shakeY = Math.sin(a)*state.shake;
  }else{
    state.shakeX = 0; state.shakeY = 0;
  }
  ctx.save();
  ctx.translate(state.shakeX, state.shakeY);

  drawBackdrop(now);
  drawCabinet();
  drawGrid();
  drawLanes(now);
  drawBumpers(now);
  drawLauncher();

  if(state.phase==="aim" || state.phase==="flight" || state.phase==="feedback"){
    drawHexBall(now);
  }
  drawFX(now);
  drawPhaseHint();

  ctx.restore();
}

/* =========================================================
   Game flow
   ========================================================= */
function startQuestion(){
  if(state.qIndex >= state.questions.length){
    endGame();
    return;
  }

  popupEl.style.display="none";
  setStatus("", false);

  const q = state.questions[state.qIndex++];
  renderQuestion(q);

  state.phase = "read";
  state.readStart = performance.now();
  state.readUntil = state.readStart + READ_PAUSE_MS;

  readWrap.style.display = "block";
  readBar.style.width = "0%";
  readSecs.textContent = (READ_PAUSE_MS/1000).toFixed(1) + "s";

  resetBall();

  setTimeout(()=>{
    if(!state.running) return;
    if(state.phase !== "read") return;

    readWrap.style.display = "none";
    state.phase = "aim";
    state.aimStart = performance.now();
    state.aimUntil = state.aimStart + AIM_TIME_LIMIT_MS;
    state.decisionStart = performance.now();
    setStatus("Aim and launch into lane A/B/C.", true);
  }, READ_PAUSE_MS);
}

function nextQuestion(){
  resetBall();
  setStatus("", false);
  setTimeout(()=> startQuestion(), 650);
}

function endGame(){
  state.running = false;
  state.phase = "end";
  readWrap.style.display="none";
  setStatus("", false);

  const acc = state.attempted ? Math.round((state.correct/state.attempted)*100) : 0;
  document.getElementById("modalTitle").textContent = "Run Completed";
  document.getElementById("modalBody").innerHTML = `
    <p><b>Participant:</b> ${escapeHtml(PID)}</p>
    <p><b>Score:</b> ${state.score} &nbsp; | &nbsp; <b>Accuracy:</b> ${acc}% &nbsp; | &nbsp; <b>Attempted:</b> ${state.attempted}</p>
    <p class="muted">Download CSV for analysis.</p>
    <div class="row" style="justify-content:flex-start; margin-top:10px; gap:10px;">
      <button class="btn" id="dlBtn">Download CSV</button>
    </div>
  `;
  overlay.style.display="flex";
  setTimeout(()=> document.getElementById("dlBtn").onclick = downloadCSV, 0);
}

function downloadCSV(){
  const rows = [["ts","pid","qid","topic","option_order","selected","intended","correct","is_correct","response_ms","score_after"]];
  for(const r of state.log){
    rows.push([r.ts,r.pid,r.qid,r.topic,r.option_order,r.selected,r.intended,r.correct,r.is_correct,r.response_ms,r.score_after]);
  }
  const csv = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download="Cyber_Pinball_Quiz_Log.csv";
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* =========================================================
   Loop
   ========================================================= */
function loop(now){
  if(state.running){
    if(state.phase==="read"){
      const total = state.readUntil - state.readStart;
      const done = clamp(now - state.readStart, 0, total);
      const pct = total > 0 ? (done/total)*100 : 100;
      readBar.style.width = pct.toFixed(1) + "%";
      readSecs.textContent = Math.max(0, (total - done)/1000).toFixed(1) + "s";
    }
    if(state.phase==="aim"){
      stepAim();
    }else if(state.phase==="flight"){
      stepFlight();
      // keep bumpers flashing nice
      for(const bm of board.bumpers) bm.flash = Math.max(0, bm.flash - 0.030);
    }
  }

  draw(now);
  requestAnimationFrame(loop);
}

/* =========================================================
   Boot
   ========================================================= */
function boot(){
  state.running = false;
  state.phase = "menu";
  state.score = 0;
  state.correct = 0;
  state.attempted = 0;
  state.qIndex = 0;
  state.log = [];
  state.particles = [];
  state.floatPop = [];
  state.shake = 0;

  state.questions = prepareQuestionsBalanced();
  qtotalEl.textContent = String(state.questions.length);

  topicBadge.textContent = "Ready";
  qTextEl.textContent = "Press Start to begin.";
  choicesEl.innerHTML = "";
  popupEl.style.display="none";
  readWrap.style.display="none";
  setStatus("", false);

  resetBall();
  updateHUD();
}
function startGame(){
  overlay.style.display="none";
  state.running = true;
  state.phase = "read";
  setStatus("Starting…", true);
  setTimeout(()=> startQuestion(), 450);
}

/* =========================================================
   Wiring buttons
   ========================================================= */
document.getElementById("restartBtn").onclick = ()=>{ overlay.style.display="none"; boot(); };
document.getElementById("startBtn").onclick = ()=>{ if(!state.running) startGame(); };

/* =========================================================
   Resize init
   ========================================================= */
function onResize(){
  fitCanvas();
  initBackdrop();
  buildBoard();
  resetBall();
}
window.addEventListener("resize", onResize);

/* =========================================================
   Initialize
   ========================================================= */
onResize();
boot();
requestAnimationFrame(loop);
</script>
</body>
</html>
```

If you want it even more “game-like”, tell me which direction you prefer and I’ll adjust the art style:

1. **Retro 8-bit arcade**,
2. **Modern neon cyber**,
3. **Minimal clean UI (Apple-like)**,
4. **Cartoon style (for younger learners)**.
